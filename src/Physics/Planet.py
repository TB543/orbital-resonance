from numpy import array
from GUI.StateManager import StateManger
from functools import partial
from pygame.mixer import Sound
from math import cos, sin, pi, atan2


class Planet:
    """
    the class to control a celestial body

    todo David use this class for calculating the physics of the planets
        the GUI will use the position, radius and color to draw it to the display
        the tag will be automatically generated by the GUI to keep track of the shape that is drawn
        feel free to add more attributes/functions as needed for physics
    """

    def __init__(self, period: float, radius: float, color: str, sound_path=None, offset=0):
        """
        creates the planet with the given attributes

        :param period: how long it takes the planet to revolve
        :param radius: the radius of the planet
        :param color: the color of the planet
        :param sound_path: the file path of to the sound to play
        """

        # physics fields
        self.period = period
        self.offset = offset

        self.orbital_radius = (period**(2/3)) * 500

        orig_x = self.orbital_radius * cos(pi/2 * (offset + 1))
        orig_y = self.orbital_radius * -sin(pi/2 * (offset + 1))

        self.original_position = array([orig_x,orig_y])

        self.position = array([orig_x,orig_y])
        self._radius = radius
        self._color = color

        # UI fields
        self.tag = None  # will be assigned by canvas
        self.update = False
        self.state_manager: StateManger = None  # will be assigned when added by to a planet manager

        # music generation fields
        self.sound_path = sound_path
        self.sound = Sound(sound_path) if sound_path else None

    def __getstate__(self):
        """
        gets the state of the planet to serialize when saving

        :return: the state of the planet excluding the play sound file object
        """

        state = self.__dict__.copy()
        del state["sound"]
        del state["state_manager"]
        return state

    def __setstate__(self, state):
        """
        restore the state of the planet after loading from file with the sound attribute

        :param state: the state without the sound attribute
        """

        self.__dict__.update(state)
        self.sound = Sound(self.sound_path) if self.sound_path else None

    def set_value(self, value, attribute: str, update: bool = True, add_state: bool = True):
        """
        handles when the user updates a value
            --> adds the state update to the state manager
            --> updates the value in the class

        ** PASSED BY PROPERTY **
        :param self: the instance of the class to update
        :param value: the value of the class to update

        ** PASSED BY PARTIAL **
        :param attribute: the attribute of the class to update
        :param update: determines if the ui will need to update after the attribute change default is true

        ** PASSED BY RECURSION **
        :param add_state: determines if the action should be added to the state manager

        :return the function to redo the action
        """

        # adds state
        undo = (self.set_value, getattr(self, attribute), attribute, update, False)
        redo = (self.set_value, value, attribute, update, False)
        self.state_manager.add_state({"undo": undo, "redo": redo}) if add_state else None

        # updates planet
        setattr(self, attribute, value)
        self.update = update

    # sets class attributes to properties so state can be stored in state manager  todo add distance from sun update
    color = property(lambda self: getattr(self, "_color"), partial(set_value, attribute="_color"))
    radius = property(lambda self: getattr(self, "_radius"), partial(set_value, attribute="_radius"))
